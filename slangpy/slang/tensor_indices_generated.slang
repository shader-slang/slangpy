// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// Tensor index extensions generated by tools/generate_tensors.py
implementing slangpy;

public extension<T, TensorType : ITensor<T, 0>> TensorType
{
    public T load()
    {
        return this._read_each();
    }
    public __subscript()->T
    {
        get { return this.load(); }
    }
}

public extension<T, TensorType : ITensor<T, 1>> TensorType
{
    public T load(int i0)
    {
        return this._read_each(i0);
    }
    public __subscript(int i0)->T
    {
        get { return this.load(i0); }
    }
}

public extension<T, TensorType : ITensor<T, 2>> TensorType
{
    public T load(int i0, int i1)
    {
        return this._read_each(i0, i1);
    }
    public __subscript(int i0, int i1)->T
    {
        get { return this.load(i0, i1); }
    }
}

public extension<T, TensorType : ITensor<T, 3>> TensorType
{
    public T load(int i0, int i1, int i2)
    {
        return this._read_each(i0, i1, i2);
    }
    public __subscript(int i0, int i1, int i2)->T
    {
        get { return this.load(i0, i1, i2); }
    }
}

public extension<T, TensorType : ITensor<T, 4>> TensorType
{
    public T load(int i0, int i1, int i2, int i3)
    {
        return this._read_each(i0, i1, i2, i3);
    }
    public __subscript(int i0, int i1, int i2, int i3)->T
    {
        get { return this.load(i0, i1, i2, i3); }
    }
}

public extension<T, TensorType : ITensor<T, 5>> TensorType
{
    public T load(int i0, int i1, int i2, int i3, int i4)
    {
        return this._read_each(i0, i1, i2, i3, i4);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4)->T
    {
        get { return this.load(i0, i1, i2, i3, i4); }
    }
}

public extension<T, TensorType : ITensor<T, 6>> TensorType
{
    public T load(int i0, int i1, int i2, int i3, int i4, int i5)
    {
        return this._read_each(i0, i1, i2, i3, i4, i5);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5)->T
    {
        get { return this.load(i0, i1, i2, i3, i4, i5); }
    }
}

public extension<T, TensorType : ITensor<T, 7>> TensorType
{
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
    {
        return this._read_each(i0, i1, i2, i3, i4, i5, i6);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6)->T
    {
        get { return this.load(i0, i1, i2, i3, i4, i5, i6); }
    }
}

public extension<T, TensorType : ITensor<T, 8>> TensorType
{
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)
    {
        return this._read_each(i0, i1, i2, i3, i4, i5, i6, i7);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)->T
    {
        get { return this.load(i0, i1, i2, i3, i4, i5, i6, i7); }
    }
}

public extension<T, TensorType : IWTensor<T, 0>> TensorType
{
    public void store(T value)
    {
        this._write_each(value);
    }
    public __subscript()->T
    {
        set { this.store(newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 1>> TensorType
{
    public void store(int i0, T value)
    {
        this._write_each(value, i0);
    }
    public __subscript(int i0)->T
    {
        set { this.store(i0, newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 2>> TensorType
{
    public void store(int i0, int i1, T value)
    {
        this._write_each(value, i0, i1);
    }
    public __subscript(int i0, int i1)->T
    {
        set { this.store(i0, i1, newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 3>> TensorType
{
    public void store(int i0, int i1, int i2, T value)
    {
        this._write_each(value, i0, i1, i2);
    }
    public __subscript(int i0, int i1, int i2)->T
    {
        set { this.store(i0, i1, i2, newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 4>> TensorType
{
    public void store(int i0, int i1, int i2, int i3, T value)
    {
        this._write_each(value, i0, i1, i2, i3);
    }
    public __subscript(int i0, int i1, int i2, int i3)->T
    {
        set { this.store(i0, i1, i2, i3, newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 5>> TensorType
{
    public void store(int i0, int i1, int i2, int i3, int i4, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4)->T
    {
        set { this.store(i0, i1, i2, i3, i4, newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 6>> TensorType
{
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4, i5);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5)->T
    {
        set { this.store(i0, i1, i2, i3, i4, i5, newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 7>> TensorType
{
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4, i5, i6);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6)->T
    {
        set { this.store(i0, i1, i2, i3, i4, i5, i6, newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 8>> TensorType
{
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4, i5, i6, i7);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)->T
    {
        set { this.store(i0, i1, i2, i3, i4, i5, i6, i7, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 0>> TensorType
{
    public T load()
    {
        return this._read_each();
    }
    public void store(T value)
    {
        this._write_each(value);
    }
    public __subscript()->T
    {
        get { return this.load(); }
        set { this.store(newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 1>> TensorType
{
    public T load(int i0)
    {
        return this._read_each(i0);
    }
    public void store(int i0, T value)
    {
        this._write_each(value, i0);
    }
    public __subscript(int i0)->T
    {
        get { return this.load(i0); }
        set { this.store(i0, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 2>> TensorType
{
    public T load(int i0, int i1)
    {
        return this._read_each(i0, i1);
    }
    public void store(int i0, int i1, T value)
    {
        this._write_each(value, i0, i1);
    }
    public __subscript(int i0, int i1)->T
    {
        get { return this.load(i0, i1); }
        set { this.store(i0, i1, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 3>> TensorType
{
    public T load(int i0, int i1, int i2)
    {
        return this._read_each(i0, i1, i2);
    }
    public void store(int i0, int i1, int i2, T value)
    {
        this._write_each(value, i0, i1, i2);
    }
    public __subscript(int i0, int i1, int i2)->T
    {
        get { return this.load(i0, i1, i2); }
        set { this.store(i0, i1, i2, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 4>> TensorType
{
    public T load(int i0, int i1, int i2, int i3)
    {
        return this._read_each(i0, i1, i2, i3);
    }
    public void store(int i0, int i1, int i2, int i3, T value)
    {
        this._write_each(value, i0, i1, i2, i3);
    }
    public __subscript(int i0, int i1, int i2, int i3)->T
    {
        get { return this.load(i0, i1, i2, i3); }
        set { this.store(i0, i1, i2, i3, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 5>> TensorType
{
    public T load(int i0, int i1, int i2, int i3, int i4)
    {
        return this._read_each(i0, i1, i2, i3, i4);
    }
    public void store(int i0, int i1, int i2, int i3, int i4, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4)->T
    {
        get { return this.load(i0, i1, i2, i3, i4); }
        set { this.store(i0, i1, i2, i3, i4, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 6>> TensorType
{
    public T load(int i0, int i1, int i2, int i3, int i4, int i5)
    {
        return this._read_each(i0, i1, i2, i3, i4, i5);
    }
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4, i5);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5)->T
    {
        get { return this.load(i0, i1, i2, i3, i4, i5); }
        set { this.store(i0, i1, i2, i3, i4, i5, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 7>> TensorType
{
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
    {
        return this._read_each(i0, i1, i2, i3, i4, i5, i6);
    }
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4, i5, i6);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6)->T
    {
        get { return this.load(i0, i1, i2, i3, i4, i5, i6); }
        set { this.store(i0, i1, i2, i3, i4, i5, i6, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 8>> TensorType
{
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)
    {
        return this._read_each(i0, i1, i2, i3, i4, i5, i6, i7);
    }
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4, i5, i6, i7);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)->T
    {
        get { return this.load(i0, i1, i2, i3, i4, i5, i6, i7); }
        set { this.store(i0, i1, i2, i3, i4, i5, i6, i7, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 0>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load()
    {
        return this._read_primal_each();
    }
    void _load_bwd_indices(T.Differential grad)
    {
        this._accumulate_grad_each(grad);
    }
    public __subscript()->T
    {
        [Differentiable] get { return this.load(); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 1>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0)
    {
        return this._read_primal_each(i0);
    }
    void _load_bwd_indices(int i0, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0);
    }
    public __subscript(int i0)->T
    {
        [Differentiable] get { return this.load(i0); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 2>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1)
    {
        return this._read_primal_each(i0, i1);
    }
    void _load_bwd_indices(int i0, int i1, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1);
    }
    public __subscript(int i0, int i1)->T
    {
        [Differentiable] get { return this.load(i0, i1); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 3>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2)
    {
        return this._read_primal_each(i0, i1, i2);
    }
    void _load_bwd_indices(int i0, int i1, int i2, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2);
    }
    public __subscript(int i0, int i1, int i2)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 4>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3)
    {
        return this._read_primal_each(i0, i1, i2, i3);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3);
    }
    public __subscript(int i0, int i1, int i2, int i3)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 5>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3, int i4)
    {
        return this._read_primal_each(i0, i1, i2, i3, i4);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, int i4, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3, i4);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3, i4); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 6>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3, int i4, int i5)
    {
        return this._read_primal_each(i0, i1, i2, i3, i4, i5);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3, i4, i5);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3, i4, i5); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 7>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
    {
        return this._read_primal_each(i0, i1, i2, i3, i4, i5, i6);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, int i6, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3, i4, i5, i6);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3, i4, i5, i6); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 8>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)
    {
        return this._read_primal_each(i0, i1, i2, i3, i4, i5, i6, i7);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3, i4, i5, i6, i7);
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3, i4, i5, i6, i7); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 0>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(T value)
    {
        this._write_primal_each(value);
    }
    void _store_bwd_indices(inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each());
    }
    public __subscript()->T
    {
        [Differentiable] set { this.store(newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 1>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, T value)
    {
        this._write_primal_each(value, i0);
    }
    void _store_bwd_indices(int i0, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0));
    }
    public __subscript(int i0)->T
    {
        [Differentiable] set { this.store(i0, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 2>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, T value)
    {
        this._write_primal_each(value, i0, i1);
    }
    void _store_bwd_indices(int i0, int i1, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1));
    }
    public __subscript(int i0, int i1)->T
    {
        [Differentiable] set { this.store(i0, i1, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 3>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, T value)
    {
        this._write_primal_each(value, i0, i1, i2);
    }
    void _store_bwd_indices(int i0, int i1, int i2, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2));
    }
    public __subscript(int i0, int i1, int i2)->T
    {
        [Differentiable] set { this.store(i0, i1, i2, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 4>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3));
    }
    public __subscript(int i0, int i1, int i2, int i3)->T
    {
        [Differentiable] set { this.store(i0, i1, i2, i3, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 5>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, int i4, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3, i4);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, int i4, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3, i4));
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4)->T
    {
        [Differentiable] set { this.store(i0, i1, i2, i3, i4, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 6>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3, i4, i5);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3, i4, i5));
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5)->T
    {
        [Differentiable] set { this.store(i0, i1, i2, i3, i4, i5, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 7>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3, i4, i5, i6);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, int i6, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3, i4, i5, i6));
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6)->T
    {
        [Differentiable] set { this.store(i0, i1, i2, i3, i4, i5, i6, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 8>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3, i4, i5, i6, i7);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3, i4, i5, i6, i7));
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)->T
    {
        [Differentiable] set { this.store(i0, i1, i2, i3, i4, i5, i6, i7, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 0>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load()
    {
        return this._read_primal_each();
    }
    void _load_bwd_indices(T.Differential grad)
    {
        this._accumulate_grad_each(grad);
    }
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(T value)
    {
        this._write_primal_each(value);
    }
    void _store_bwd_indices(inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each());
    }
    public __subscript()->T
    {
        [Differentiable] get { return this.load(); }
        [Differentiable] set { this.store(newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 1>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0)
    {
        return this._read_primal_each(i0);
    }
    void _load_bwd_indices(int i0, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0);
    }
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, T value)
    {
        this._write_primal_each(value, i0);
    }
    void _store_bwd_indices(int i0, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0));
    }
    public __subscript(int i0)->T
    {
        [Differentiable] get { return this.load(i0); }
        [Differentiable] set { this.store(i0, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 2>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1)
    {
        return this._read_primal_each(i0, i1);
    }
    void _load_bwd_indices(int i0, int i1, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1);
    }
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, T value)
    {
        this._write_primal_each(value, i0, i1);
    }
    void _store_bwd_indices(int i0, int i1, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1));
    }
    public __subscript(int i0, int i1)->T
    {
        [Differentiable] get { return this.load(i0, i1); }
        [Differentiable] set { this.store(i0, i1, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 3>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2)
    {
        return this._read_primal_each(i0, i1, i2);
    }
    void _load_bwd_indices(int i0, int i1, int i2, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2);
    }
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, T value)
    {
        this._write_primal_each(value, i0, i1, i2);
    }
    void _store_bwd_indices(int i0, int i1, int i2, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2));
    }
    public __subscript(int i0, int i1, int i2)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2); }
        [Differentiable] set { this.store(i0, i1, i2, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 4>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3)
    {
        return this._read_primal_each(i0, i1, i2, i3);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3);
    }
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3));
    }
    public __subscript(int i0, int i1, int i2, int i3)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3); }
        [Differentiable] set { this.store(i0, i1, i2, i3, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 5>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3, int i4)
    {
        return this._read_primal_each(i0, i1, i2, i3, i4);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, int i4, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3, i4);
    }
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, int i4, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3, i4);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, int i4, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3, i4));
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3, i4); }
        [Differentiable] set { this.store(i0, i1, i2, i3, i4, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 6>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3, int i4, int i5)
    {
        return this._read_primal_each(i0, i1, i2, i3, i4, i5);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3, i4, i5);
    }
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3, i4, i5);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3, i4, i5));
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3, i4, i5); }
        [Differentiable] set { this.store(i0, i1, i2, i3, i4, i5, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 7>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
    {
        return this._read_primal_each(i0, i1, i2, i3, i4, i5, i6);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, int i6, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3, i4, i5, i6);
    }
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3, i4, i5, i6);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, int i6, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3, i4, i5, i6));
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3, i4, i5, i6); }
        [Differentiable] set { this.store(i0, i1, i2, i3, i4, i5, i6, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 8>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)
    {
        return this._read_primal_each(i0, i1, i2, i3, i4, i5, i6, i7);
    }
    void _load_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1, i2, i3, i4, i5, i6, i7);
    }
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, T value)
    {
        this._write_primal_each(value, i0, i1, i2, i3, i4, i5, i6, i7);
    }
    void _store_bwd_indices(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1, i2, i3, i4, i5, i6, i7));
    }
    public __subscript(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)->T
    {
        [Differentiable] get { return this.load(i0, i1, i2, i3, i4, i5, i6, i7); }
        [Differentiable] set { this.store(i0, i1, i2, i3, i4, i5, i6, i7, newValue); }
    }
}

public extension<T> AtomicTensor<T, 0> where T : IAtomicAddable
{
    public T load()
    {
        return this._read_each();
    }
    public void store(T value)
    {
        this._write_each(value);
    }
    public void add(T value)
    {
        this._accumulate_each(value);
    }
}

public extension<T> AtomicTensor<T, 1> where T : IAtomicAddable
{
    public T load(int i0)
    {
        return this._read_each(i0);
    }
    public void store(int i0, T value)
    {
        this._write_each(value, i0);
    }
    public void add(int i0, T value)
    {
        this._accumulate_each(value, i0);
    }
}

public extension<T> AtomicTensor<T, 2> where T : IAtomicAddable
{
    public T load(int i0, int i1)
    {
        return this._read_each(i0, i1);
    }
    public void store(int i0, int i1, T value)
    {
        this._write_each(value, i0, i1);
    }
    public void add(int i0, int i1, T value)
    {
        this._accumulate_each(value, i0, i1);
    }
}

public extension<T> AtomicTensor<T, 3> where T : IAtomicAddable
{
    public T load(int i0, int i1, int i2)
    {
        return this._read_each(i0, i1, i2);
    }
    public void store(int i0, int i1, int i2, T value)
    {
        this._write_each(value, i0, i1, i2);
    }
    public void add(int i0, int i1, int i2, T value)
    {
        this._accumulate_each(value, i0, i1, i2);
    }
}

public extension<T> AtomicTensor<T, 4> where T : IAtomicAddable
{
    public T load(int i0, int i1, int i2, int i3)
    {
        return this._read_each(i0, i1, i2, i3);
    }
    public void store(int i0, int i1, int i2, int i3, T value)
    {
        this._write_each(value, i0, i1, i2, i3);
    }
    public void add(int i0, int i1, int i2, int i3, T value)
    {
        this._accumulate_each(value, i0, i1, i2, i3);
    }
}

public extension<T> AtomicTensor<T, 5> where T : IAtomicAddable
{
    public T load(int i0, int i1, int i2, int i3, int i4)
    {
        return this._read_each(i0, i1, i2, i3, i4);
    }
    public void store(int i0, int i1, int i2, int i3, int i4, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4);
    }
    public void add(int i0, int i1, int i2, int i3, int i4, T value)
    {
        this._accumulate_each(value, i0, i1, i2, i3, i4);
    }
}

public extension<T> AtomicTensor<T, 6> where T : IAtomicAddable
{
    public T load(int i0, int i1, int i2, int i3, int i4, int i5)
    {
        return this._read_each(i0, i1, i2, i3, i4, i5);
    }
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4, i5);
    }
    public void add(int i0, int i1, int i2, int i3, int i4, int i5, T value)
    {
        this._accumulate_each(value, i0, i1, i2, i3, i4, i5);
    }
}

public extension<T> AtomicTensor<T, 7> where T : IAtomicAddable
{
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6)
    {
        return this._read_each(i0, i1, i2, i3, i4, i5, i6);
    }
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4, i5, i6);
    }
    public void add(int i0, int i1, int i2, int i3, int i4, int i5, int i6, T value)
    {
        this._accumulate_each(value, i0, i1, i2, i3, i4, i5, i6);
    }
}

public extension<T> AtomicTensor<T, 8> where T : IAtomicAddable
{
    public T load(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7)
    {
        return this._read_each(i0, i1, i2, i3, i4, i5, i6, i7);
    }
    public void store(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, T value)
    {
        this._write_each(value, i0, i1, i2, i3, i4, i5, i6, i7);
    }
    public void add(int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7, T value)
    {
        this._accumulate_each(value, i0, i1, i2, i3, i4, i5, i6, i7);
    }
}
