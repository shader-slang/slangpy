// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

// This file is auto-generated by tools/generate_tensors.py

implementing slangpy;

int _idx(uint stride[0], uint offset) { return offset; }int _idx(int idx0, uint stride[1], uint offset)
{
    int idx = 0;
    idx += idx0 * stride[0];
    return idx + offset;
}
int _idx(int idx0, int idx1, uint stride[2], uint offset)
{
    int idx = 0;
    idx += idx0 * stride[0];
    idx += idx1 * stride[1];
    return idx + offset;
}
public extension<T> Tensor<T, 0>
{
    public __subscript()->T
    {
        get { return this.load(); }
    }
}

public extension<T, TensorType : ITensor<T, 0>> TensorType
{
    public T load()
    {
        return this._read_each();
    }
}

public extension<T> Tensor<T, 1>
{
    public __subscript(int i0)->T
    {
        get { return this.load(i0); }
    }
}

public extension<T, TensorType : ITensor<T, 1>> TensorType
{
    public T load(int i0)
    {
        return this._read_each(i0);
    }
}

public extension<T> Tensor<T, 2>
{
    public __subscript(int i0, int i1)->T
    {
        get { return this.load(i0, i1); }
    }
}

public extension<T, TensorType : ITensor<T, 2>> TensorType
{
    public T load(int i0, int i1)
    {
        return this._read_each(i0, i1);
    }
}

public extension<T> WTensor<T, 0>
{
    public __subscript()->T
    {
        set { this.store(newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 0>> TensorType
{
    public void store(T value)
    {
        this._write_each(value);
    }
}

public extension<T> WTensor<T, 1>
{
    public __subscript(int i0)->T
    {
        set { this.store(i0, newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 1>> TensorType
{
    public void store(int i0, T value)
    {
        this._write_each(value, i0);
    }
}

public extension<T> WTensor<T, 2>
{
    public __subscript(int i0, int i1)->T
    {
        set { this.store(i0, i1, newValue); }
    }
}

public extension<T, TensorType : IWTensor<T, 2>> TensorType
{
    public void store(int i0, int i1, T value)
    {
        this._write_each(value, i0, i1);
    }
}

public extension<T> RWTensor<T, 0>
{
    public __subscript()->T
    {
        get { return this.load(); }
        set { this.store(newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 0>> TensorType
{
}

public extension<T> RWTensor<T, 1>
{
    public __subscript(int i0)->T
    {
        get { return this.load(i0); }
        set { this.store(i0, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 1>> TensorType
{
}

public extension<T> RWTensor<T, 2>
{
    public __subscript(int i0, int i1)->T
    {
        get { return this.load(i0, i1); }
        set { this.store(i0, i1, newValue); }
    }
}

public extension<T, TensorType : IRWTensor<T, 2>> TensorType
{
}

public extension<T: IDifferentiable> DiffTensor<T, 0> where T.Differential : IAtomicAddable
{
    public __subscript()->T
    {
        [Differentiable] get { return this.load(); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 0>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load()
    {
        return this._read_primal_each();
    }
    void _load_bwd_indices(T.Differential grad)
    {
        this._accumulate_grad_each(grad);
    }
}

public extension<T: IDifferentiable> DiffTensor<T, 1> where T.Differential : IAtomicAddable
{
    public __subscript(int i0)->T
    {
        [Differentiable] get { return this.load(i0); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 1>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0)
    {
        return this._read_primal_each(i0);
    }
    void _load_bwd_indices(int i0, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0);
    }
}

public extension<T: IDifferentiable> DiffTensor<T, 2> where T.Differential : IAtomicAddable
{
    public __subscript(int i0, int i1)->T
    {
        [Differentiable] get { return this.load(i0, i1); }
    }
}

public extension<T: IDifferentiable, TensorType : IDiffTensor<T, 2>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_load_bwd_indices)]
    public T load(int i0, int i1)
    {
        return this._read_primal_each(i0, i1);
    }
    void _load_bwd_indices(int i0, int i1, T.Differential grad)
    {
        this._accumulate_grad_each(grad, i0, i1);
    }
}

public extension<T: IDifferentiable> WDiffTensor<T, 0> where T.Differential : IAtomicAddable
{
    public __subscript()->T
    {
        [Differentiable] set { this.store(newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 0>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(T value)
    {
        this._write_primal_each(value);
    }
    void _store_bwd_indices(inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each());
    }
}

public extension<T: IDifferentiable> WDiffTensor<T, 1> where T.Differential : IAtomicAddable
{
    public __subscript(int i0)->T
    {
        [Differentiable] set { this.store(i0, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 1>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, T value)
    {
        this._write_primal_each(value, i0);
    }
    void _store_bwd_indices(int i0, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0));
    }
}

public extension<T: IDifferentiable> WDiffTensor<T, 2> where T.Differential : IAtomicAddable
{
    public __subscript(int i0, int i1)->T
    {
        [Differentiable] set { this.store(i0, i1, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IWDiffTensor<T, 2>> TensorType where T.Differential : IAtomicAddable
{
    [Differentiable]
    [BackwardDerivative(_store_bwd_indices)]
    public void store(int i0, int i1, T value)
    {
        this._write_primal_each(value, i0, i1);
    }
    void _store_bwd_indices(int i0, int i1, inout DifferentialPair<T> grad)
    {
        grad = diffPair(grad.p, this._read_grad_each(i0, i1));
    }
}

public extension<T: IDifferentiable> RWDiffTensor<T, 0> where T.Differential : IAtomicAddable
{
    public __subscript()->T
    {
        [Differentiable] get { return this.load(); }
        [Differentiable] set { this.store(newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 0>> TensorType where T.Differential : IAtomicAddable
{
}

public extension<T: IDifferentiable> RWDiffTensor<T, 1> where T.Differential : IAtomicAddable
{
    public __subscript(int i0)->T
    {
        [Differentiable] get { return this.load(i0); }
        [Differentiable] set { this.store(i0, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 1>> TensorType where T.Differential : IAtomicAddable
{
}

public extension<T: IDifferentiable> RWDiffTensor<T, 2> where T.Differential : IAtomicAddable
{
    public __subscript(int i0, int i1)->T
    {
        [Differentiable] get { return this.load(i0, i1); }
        [Differentiable] set { this.store(i0, i1, newValue); }
    }
}

public extension<T: IDifferentiable, TensorType : IRWDiffTensor<T, 2>> TensorType where T.Differential : IAtomicAddable
{
}

public extension<T: IDifferentiable> PrimalTensor<T, 0> where T.Differential : IAtomicAddable
{
    public __subscript()->T
    {
        get { return this.load(); }
    }
}

public extension<T: IDifferentiable> PrimalTensor<T, 1> where T.Differential : IAtomicAddable
{
    public __subscript(int i0)->T
    {
        get { return this.load(i0); }
    }
}

public extension<T: IDifferentiable> PrimalTensor<T, 2> where T.Differential : IAtomicAddable
{
    public __subscript(int i0, int i1)->T
    {
        get { return this.load(i0, i1); }
    }
}

public extension<T: IDifferentiable> WPrimalTensor<T, 0> where T.Differential : IAtomicAddable
{
    public __subscript()->T
    {
        set { this.store(newValue); }
    }
}

public extension<T: IDifferentiable> WPrimalTensor<T, 1> where T.Differential : IAtomicAddable
{
    public __subscript(int i0)->T
    {
        set { this.store(i0, newValue); }
    }
}

public extension<T: IDifferentiable> WPrimalTensor<T, 2> where T.Differential : IAtomicAddable
{
    public __subscript(int i0, int i1)->T
    {
        set { this.store(i0, i1, newValue); }
    }
}

public extension<T: IDifferentiable> RWPrimalTensor<T, 0> where T.Differential : IAtomicAddable
{
    public __subscript()->T
    {
        get { return this.load(); }
        set { this.store(newValue); }
    }
}

public extension<T: IDifferentiable> RWPrimalTensor<T, 1> where T.Differential : IAtomicAddable
{
    public __subscript(int i0)->T
    {
        get { return this.load(i0); }
        set { this.store(i0, newValue); }
    }
}

public extension<T: IDifferentiable> RWPrimalTensor<T, 2> where T.Differential : IAtomicAddable
{
    public __subscript(int i0, int i1)->T
    {
        get { return this.load(i0, i1); }
        set { this.store(i0, i1, newValue); }
    }
}

public extension<T> AtomicTensor<T, 0> where T : IAtomicAddable
{
    public T load()
    {
        return this._read_each();
    }
    public void store(T value)
    {
        this._write_each(value);
    }
    public void add(T value)
    {
        int idx = _idx(this._strides, this._offset);
        StorageTraits<T>::atomicAdd(_data, idx, value);
    }
    public __subscript()->T
    {
        get { return this.load(); }
        set { this.store(newValue); }
    }
}

public extension<T> AtomicTensor<T, 1> where T : IAtomicAddable
{
    public T load(int i0)
    {
        return this._read_each(i0);
    }
    public void store(int i0, T value)
    {
        this._write_each(value, i0);
    }
    public void add(int i0, T value)
    {
        int idx = _idx(i0, this._strides, this._offset);
        StorageTraits<T>::atomicAdd(_data, idx, value);
    }
    public __subscript(int i0)->T
    {
        get { return this.load(i0); }
        set { this.store(i0, newValue); }
    }
}

public extension<T> AtomicTensor<T, 2> where T : IAtomicAddable
{
    public T load(int i0, int i1)
    {
        return this._read_each(i0, i1);
    }
    public void store(int i0, int i1, T value)
    {
        this._write_each(value, i0, i1);
    }
    public void add(int i0, int i1, T value)
    {
        int idx = _idx(i0, i1, this._strides, this._offset);
        StorageTraits<T>::atomicAdd(_data, idx, value);
    }
    public __subscript(int i0, int i1)->T
    {
        get { return this.load(i0, i1); }
        set { this.store(i0, i1, newValue); }
    }
}
